{"meta":{"title":"小余哥","subtitle":"","description":"小余哥个人博客，致力于分享一些技术教程和有趣的技术实践，以及日常踩坑记录。","author":"小余哥","url":"https://xiaoyuge5201.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-23T08:39:18.817Z","updated":"2021-07-23T08:39:18.817Z","comments":false,"path":"/404.html","permalink":"https://xiaoyuge5201.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-07-23T08:39:18.762Z","updated":"2021-07-23T08:39:18.762Z","comments":false,"path":"books/index.html","permalink":"https://xiaoyuge5201.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-23T08:39:18.808Z","updated":"2021-07-23T08:39:18.808Z","comments":false,"path":"about/index.html","permalink":"https://xiaoyuge5201.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-07-23T08:39:18.761Z","updated":"2021-07-23T08:39:18.761Z","comments":false,"path":"categories/index.html","permalink":"https://xiaoyuge5201.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-23T08:39:18.760Z","updated":"2021-07-23T08:39:18.760Z","comments":true,"path":"links/index.html","permalink":"https://xiaoyuge5201.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-23T08:39:18.810Z","updated":"2021-07-23T08:39:18.810Z","comments":false,"path":"repository/index.html","permalink":"https://xiaoyuge5201.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-23T08:39:18.808Z","updated":"2021-07-23T08:39:18.808Z","comments":false,"path":"tags/index.html","permalink":"https://xiaoyuge5201.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mycat学习","slug":"mycat","date":"2021-07-23T08:16:49.000Z","updated":"2021-07-23T08:43:38.090Z","comments":false,"path":"2021/07/23/mycat/","link":"","permalink":"https://xiaoyuge5201.github.io/2021/07/23/mycat/","excerpt":"","text":"Mycat(分库分表中间件) 1. 数据库优化策略 重启：释放资源 SQL与索引 表与存储引擎（字段类型选择，长度设置，是否需要分表、分区） 数据库与应用架构（考虑使用缓存服务器，减轻是数据库压力；可以数据库分布式，读写分离，主从复制） 数据库与操作系统配置（修改mysql配置，使用单独服务器部署数据库） 硬件 2. 数据库演化 根据业务需要、数据量变化，随之而来的数据库的变化 数据库与应用部署在同一台服务器 单体应用架构，单数据库（数据库服务器和应用服务器分离，但是业务系统越做越大） 多应用单数据库（应用解耦） 多应用 独立数据库 但应用多数据库(分表) 3. 如何分库分表 垂直切分 垂直切分 单库 多库 水平切分 按照月分表或者分成实时、历史表等 分成多库 4. 分库分表带来的问题 跨库关联查询 增加冗余字段（违反了第三范式：表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系） 跨数据库的同步（canal、Mq（最好）、ETL、kettle、ogg）(在某个库中同步其他数据库中表的数据，避免跨库关联查询) 全局表(广播表)：比如行政区划表，所有的系统都是一样的； API 分布式事务 Local 排序、翻页、函数计算 全局主键 雪花算法leaf redis(int 类型可以设置incby) ZookKeeper uuid(数据过长， 影响索引存储) 多数据源连接（动态数据源） 5. Mycat分库分表中间件 官网地址：http://www.mycat.org.cn/ 从阿里cobar升级而来，完全实现了mysql协议，可以当作一个mysql数据库来使用，通过JDBC支持其他数据库实现分库分表，解决了多表join、分布式事务、全局序列号、翻页查询、函数计算的问题 一个彻底开源的，面向企业应用开发的大数据库集群 支持事务、ACID、可以替代MySQL的加强版数据库 一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群 一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server 结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品 一个新颖的数据库中间件产品 华为云的DDM其实也是根据mycat做的 5.1 核心概念 5.2 Mycat安装与配置 5.2.1 Mycat安装 从官网下载安装版本，解压到文件(官网建议安装在/usr/local/Mycat)后页面如下图所示： 目录解释如下： **bin：*存放window版和linux版本除了提供封装成服务的版本之外，也提供了nowrap的shell脚本命令，方便选择和修改；Linux下运行:./mycat console， 首先要chmod + x;(mycat支持的命令console、start、stop、restart、status、dump) **conf：**server.xml是mycat服务器参数调整和用户授权的配置文件，schema.xml是逻辑库定义和表以及分片定义的配置文件，rule.xml是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改，需要重启mycat或者通过9066端口reload **lib:**主要存放mycat依赖的一些jar文件 logs:日志存放在mycat.log中，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要，可以调整输出级别为debug，方便排查问题；注意Linux下部署安装mysql，默认不忽略，需要手动到/etc/my.cnf下配置lower_case_table_names=1使Linux环境下MySQL忽略表明大小写，否则使用mycat的时候会提示找不到表的错误 5.2.2 服务启动与配置 Mycat在Linux中部署启动时，首先需要在Linux系统的环境变量中配置MYCAT_HOE,操作方式如下： vi /etc/profile，在系统环境变量文件中增加MYCAT_HOME=/usr/lib/tools/mycat 执行 source/etc/profile命令，使环境变量生效。如果是多台Linux系统中组件Mycat集群，那需要在mycat Server所在的服务器配置对其他ip和主机名的映射，配置方式如下： 经过以上两个步骤的配置，就可以到/usr/lib/tools/mycat/bin目录下执行./mycat start启动mycat服务；使用mycat status查看mycat的运行状态；如下图 5.2.2.1 安装遇到的问题 schema TESTDB refered by user root is not exist! 解决方式： 12345678&lt;!--在conf/server.xml文件中schemas中配置schema.xml文件中的schema的name值--&gt;&lt;!--user中的name为mycat服务的用户名--&gt; &lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt; &lt;!--这个是mycat服务连接的密码--&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;xiaoyuge&lt;/property&gt;&lt;/user&gt; 5.2.3日志分析 mycat的日志文件配置为MYCAT_HOME/conf/log4j.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt; &lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;ConsoleAppender&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d&#123;MM-dd HH:mm:ss.SSS&#125; %5p [%t] (%F:%L) -%m%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=&quot;FILE&quot; class=&quot;org.apache.log4j.RollingFileAppender&quot;&gt; &lt;!--日志文件存放的目录--&gt; &lt;param name=&quot;file&quot; value=&quot;$&#123;MYCAT_HOME&#125;/logs/mycat.log&quot; /&gt; &lt;param name=&quot;Append&quot; value=&quot;false&quot;/&gt; &lt;param name=&quot;MaxFileSize&quot; value=&quot;10000KB&quot;/&gt; &lt;param name=&quot;MaxBackupIndex&quot; value=&quot;10&quot;/&gt; &lt;param name=&quot;encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d&#123;MM/dd HH:mm:ss.SSS&#125; %5p [%t] (%F:%L) -%m%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;!--level是日志级别，生产环境下加以将级别调整为info/ware，如果是研究测试，碰到异常设置为debug--&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;ConsoleAppender&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 5.2.3.1 warpper日志 目前mycat的启动时经过warpper封装成启动脚本，所以日志也会有其相关的日志文件：${MYCAT_HOME}/logs/warapper.log， 在启动的时候如果系统环境配置错误或缺少配置时，导致mycat无法启动，可以通过查看wrapper.log查看具体错误原因。 正常启动 1234567STATUS | wrapper | 2015/04/12 15:05:00 | --&gt; Wrapper Started as DaemonSTATUS | wrapper | 2015/04/12 15:05:00 | Launching a JVM...INFO | jvm 1 | 2015/04/12 15:05:01 | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.orgINFO | jvm 1 | 2015/04/12 15:05:01 | Copyright 1999-2006 Tanuki Software, Inc. AllRights Reserved.INFO | jvm 1 | 2015/04/12 15:05:01 |INFO | jvm 1 | 2015/04/12 15:05:01 | log4j 2015-04-12 15:05:01 [./conf/log4j.xml]load completed.INFO | jvm 1 | 2015/04/12 15:05:02 | MyCAT Server startup successfully. see logs in logs/mycat.log 启动异常 1234567891011STATUS | wrapper | 2015/02/14 01:43:44 | --&gt; Wrapper Started as DaemonSTATUS | wrapper | 2015/02/14 01:43:44 | Launching a JVM...INFO | jvm 1 | 2015/02/14 01:43:45 | Error: Exception thrown by the agent : java.rmi.server.ExportException:Port already in use: 1984; nested exception is:INFO | jvm 1 | 2015/02/14 01:43:45 | java.net.BindException: Address already in useERROR | wrapper | 2015/02/14 01:43:45 | JVM exited while loading the application. # 日志显示异常原因为 java.net.BindException: Address already in use,也就是端口占用，很有可能是原有服务未停止，或者 Mycat 默认端口被其他程序占用，正常启动成功后会有 mycat.log 日志，如果服务未启动成功不会有对应的日志。 也可以去修改 conf 文件夹里的 wrapper.conf 里的 wrapper.java.additional.7=-Dcom.sun.management.jmxremote.port=1984，server.xml 的&lt;property name=&quot;serverPort&quot;&gt;8066&lt;/property&gt;和&lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt;，这方法适合一台机器上两个 mycat 或者 1984,8066,9066 端口被其它应用占用的情况 5.2.3.2 mycat日志 5.2.4 mycat防火墙设置 白名单和SQL黑名单说明： 12345678910111213&lt;!--在 server.xml 中配置：--&gt;&lt;firewall&gt; &lt;!--ip 白名单列表，可以配置多个--&gt; &lt;whitehost&gt; &lt;!--ip 白名单 用户对应的可以访问的 ip 地址--&gt; &lt;host user=&quot;mycat&quot; host=&quot;127.0.0.1&quot;&gt;&lt;/host&gt; &lt;/whitehost&gt; &lt;!-是否开启检查黑名单列表--&gt; &lt;blacklist check=&quot;true&quot;&gt; &lt;!--黑名单允许的 权限 后面为默认--&gt; &lt;property name=&quot;selelctAllow&quot;&gt;false&lt;/property&gt; &lt;/blacklist&gt;&lt;/firewall&gt; 黑名单配置拦截明细如下： 配置项 缺省值 描述 rollbackAllow true 是否允许执行 roll back 操作,如果把 selectIntoAllow、deleteAllow、updateAllow、insertAllow、mergeAllow 都设置为 false，这就是一个只读数据源了。 selectAllow true 是否运行执行SELECT语句 selectAllColumnAllow true 是否允许执行 SELECT * FROM T 这样的语句。如果设置为 false，不允许执行 select * from t，但 select * from (select id, name from t) a。这个选项是防御程序通过调用 select *获得数据表的结构信息 selectIntoAllow true SELECT 查询中是否允许 INTO 字句 deleteAllow true 是否允许执行 DELETE 语句 updateAllow true 是否允许执行 UPDATE 语句 insertAllow true 是否允许执行 INSERT 语句 replaceAllow true 是否允许执行 REPLACE 语句 mergeAllow true 是否允许执行 MERGE 语句，这个只在 Oracle 中有用 callAllow true 是否允许通过 jdbc 的 call 语法调用存储过程 setAllow true 是否允许使用 SET 语法 truncateAllow true truncate 语句是危险，缺省打开，若需要自行关闭 createTableAllow true 是否允许创建表 alterTableAllow true 是否允许执行 Alter Table 语句 dropTableAllow true 是否允许修改表 commentAllow false 是否允许语句中存在注释，Oracle 的用户不用担心，Wall 能够识别 hints和注释的区别 noneBaseStatementAllow false 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项 就能够屏蔽 DDL。 multiStatementAllow false 是否允许一次执行多条语句，缺省关闭 useAllow true 是否允许执行 mysql 的 use 语句，缺省打开 describeAllow true 是否允许执行 mysql 的 describe 语句，缺省打开 showAllow true 是否允许执行 mysql 的 show 语句，缺省打开 commitAllow true 是否允许执行 commit 操作 拦截配置=-永真条件： 配置项 缺省值 描述 selectWhereAlwayTrueCheck true 检查 SELECT 语句的 WHERE 子句是否是一个永真条件 selectHavingAlwayTrueCheck true 检查 SELECT 语句的 HAVING 子句是否是一个永真条件 deleteWhereAlwayTrueCheck true 检查 DELETE 语句的 WHERE 子句是否是一个永真条件 deleteWhereNoneCheck false 检查 DELETE 语句是否无 where 条件，这是有风险的，但不是 SQL 注入类型的风险 updateWhereAlayTrueCheck true 检查 UPDATE 语句的 WHERE 子句是否是一个永真条件 updateWhereNoneCheck false 检查 UPDATE 语句是否无 where 条件，这是有风险的，但不是SQL 注入类型的风险 conditionAndAlwayTrueAllow false 检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永真条件 conditionAndAlwayFalseAllow false 检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永假条件 conditionLikeTrueAllow true 检查查询条件(WHERE/HAVING 子句)中是否包含 LIKE 永真条件 其他拦截配置： 配置项 缺省值 描述 selectIntoOutfileAllow false SELECT … INTO OUTFILE 是否允许，这个是 mysql 注入攻击的常见手段，缺省是禁止的 selectUnionCheck true 检测 SELECT UNION selectMinusCheck true 检测 SELECT MINUS selectExceptCheck true 检测 SELECT EXCEPT selectIntersectCheck true 检测 SELECT INTERSECT mustParameterized false 是否必须参数化，如果为 True，则不允许类似 WHERE ID = 1 这种不参数化的 SQL strictSyntaxCheck true 是否进行严格的语法检测，Druid SQL Parser 在某些场景不能覆盖所有的，SQL 语法，出现解析 SQL 出错，可以临时把这个选项设置为 false，同时把 SQL 反馈给 Druid 的开发者 conditionOpXorAllow false 查询条件中是否允许有 XOR 条件。XOR 不常用，很难判断永真或者永假，缺省不允许。 conditionOpBitwseAllow true 查询条件中是否允许有&quot;&amp;&quot;、&quot;~&quot;、&quot; conditionDoubleConstAllow false 查询条件中是否允许连续两个常量运算表达式 minusAllow true 是否允许 SELECT * FROM A MINUS SELECT * FROM B 这样的语句 intersectAllow true 是否允许 SELECT * FROM A INTERSECT SELECT * FROM B 这样的语句 constArithmeticAllow true 拦截常量运算的条件，比如说 WHERE FID = 3 - 1，其中&quot;3 - 1&quot;是常量运算表达式。 limitZeroAllow false 是否允许 limit 0 这样的语句 禁用对象检测配置： 配置项 缺省值 描述 tableCheck true 检测是否使用了禁用的表 schemaCheck true 检测是否使用了禁用的 Schema functionCheck true 检测是否使用了禁用的函数 objectCheck true 检测是否使用了“禁用对对象” variantCheck true 检测是否使用了“禁用的变量” readOnlyTables 空 指定的表只读，不能够在 SELECT INTO、DELETE、UPDATE、INSERT、MERGE 中作为&quot;被修改表&quot;出现 5.2.5 mycat配置文件 5.2.5.1 schema.xml配置 schema.xml作为mycat中重要的配置文件之一，管理者mycat的逻辑库、表、分片规则、DataNode以及DataSource。 5.2.5.2 scheme标签 1&lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt;&lt;/schema&gt; schema标签用于定义mycat实例中的逻辑库，mycat可以由多个逻辑库，每个逻辑库都有自己的相关配置，可以使用schema标签来划分这些不同的逻辑库。如果不配置schema标签，所有的表配置，会属于同一个默认的逻辑库。 1234567891011&lt;!--逻辑库TESTDB--&gt;&lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;table name=&quot;travelrecord&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;auto-sharding-long&quot; &gt;&lt;/table&gt;&lt;/schema&gt;&lt;!--USERDB--&gt;&lt;schema name=&quot;USERDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;table name=&quot;company&quot; dataNode=&quot;dn10,dn11,dn12&quot; rule=&quot;auto-sharding-long&quot; &gt;&lt;/table&gt;&lt;/schema&gt;&lt;!-- 逻辑库的概念和MySQL数据库中的database概念相同，我们在查询这两个不同的逻辑库中表的时候需要切换到该逻辑库下才可以查询到所需要的表--&gt; 在server.xml中可以配置不同的用户能够使用的schema 123456789101112131415161718192021222324&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt; &lt;property name=&quot;defaultSchema&quot;&gt;TESTDB&lt;/property&gt; &lt;!--No MyCAT Database selected 错误前会尝试使用该schema作为schema，不设置则为null,报错 --&gt; &lt;!-- 表级 DML 权限设置 --&gt; &lt;!-- &lt;privileges check=&quot;false&quot;&gt; &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt; &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt; &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt; &lt;/schema&gt; &lt;/privileges&gt; --&gt;&lt;/user&gt;&lt;user name=&quot;user&quot;&gt; &lt;property name=&quot;password&quot;&gt;user&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt; &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;defaultSchema&quot;&gt;TESTDB&lt;/property&gt;&lt;/user&gt; schema标签的相关属性： 属性名 值 数量限制 dataNode 任意string （0…1） checkSQLschema Boolean （1） sqlMaxLimit Integer （1） 5.2.5.2.1 dataNode 该属性用于绑定逻辑库到某个具体的database上，1.3版本如果配置了dataNode,则不可以配置分片表，1.4可以配置默认分片，只需要配置需要分片的表即可，具体配置如下： 1&lt;!--1.3版本配置--&gt;&lt;schema name=&quot;USERDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;&lt;!—里面不能配置任何表--&gt;&lt;/schema&gt;&lt;!--1.4版本配置--&gt;&lt;schema name=&quot;USERDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn2&quot;&gt;&lt;!—配置需要分片的表--&gt; &lt;table name=“tuser” dataNode=”dn1”/&gt;&lt;/schema&gt;&lt;!-- 那么现在tuser就绑定到dn1所配置的具体database上，可以直接访问这个database，没有配置的表则会走默认的节点dn2，这里注意没有配置在分片里面的表工具查看无法显示，但是可以正常使用。--&gt; 5.2.5.2.2 checkSQLschema 当改制设置为true时，我们执行“SELECT * FROM TESTDB.travelrecord；”则mycat会把语句修改为“SELECT * FROM travelrecord;”即把表示schema的字符去掉，避免发送到后端数据库执行报ERROR 1146：Table ‘testdb.travelrecord’ doest’t exist.不过，即使设置该值为 true ，如果语句所带的是并非是 schema 指定的名字，例如：select * from db1.travelrecord; 那么 MyCat 并不会删除 db1 这个字段，如果没有定义该库的话则会报错，所以在提供 SQL语句的最好是不带这个字段。 5.2.5.2.3 sqlMaxLimit 当该值设置为某个数值时。每条执行的 SQL 语句，如果没有加上 limit 语句，MyCat 也会自动的加上所对应的值。例如设置值为 100，执行**select * from TESTDB.travelrecord;的效果为和执行select * from TESTDB.travelrecord limit 100;**相同。 设置该值的话，MyCat 默认会把查询到的信息全部都展示出来，造成过多的输出。所以，在正常使用中，还是建议加上一个值，用于减少过多的数据返回。 当然 SQL 语句中也显式的指定 limit 的大小，不受该属性的约束。 需要注意的是，如果运行的 schema 为非拆分库的，那么该属性不会生效。需要手动添加 limit 语句。 5.2 分配规则 范围分片：根据某个字设置auto-sharding-long，如果这个primaryKey超出了范围会报错 取模分片： ER分片（将父子表有关联的数据放在一个data-node里面） 全局表：所有dataNode存储相同的数据，查询的时候是随机查询某个表 type=global，查询的时候随机从某个datanode获取 非分片表：只在某个dataNode上存储,指定一个dataNode并且不写分片规则 单库分表：有个bug在实际数据库中必须要创建mycat中一摸一样的数据表，而且truncat的时候要现在dataNode先删除，才能删除的掉mycat的数据 5.3 全局ID 文件方式—0 数据库方式—1 本地时间戳----2 ZK方式----3 6. Mycat分片策略详解 连续分片与离散分片 连续分片： 范围分片 日期/事件 缺点： 存在数据热点的可能性 并发访问能力受限于单一或少量DataNode（访问集中），并不能分摊数据库访问的压力 离散： 取模（partioncount 的总数必须和分片总数相同） 枚举 一致性哈希(qs-murmur) 固定分片哈希 partitionCount: 2, 1表示有三个分片必须和节点数量一致，否则会报错，前面两个一样长 partitionLength: 256, 512表示长度为256和512 综合在一起就是前面2个分片长度为256， 最后一个为512，结果如下图所示（注意partitionCount和partitionLength的数量一定要一致） 取模范围(sharting-by-pattern)：先取模PartitionByPattern后分片 范围取模: PartitionByRangeMod(partition-rane-mod.txt) 0-2000=1 #范围在2000以内的在第一个节点（取模的结果还是本身） 2001-4000=2 #范围在2001到4000以内的再模2，结果为0在第一个节点，结果为1在第三个节点 12345678910111213141516171819202122232425262728293031323334353637- 其他优点：- 并发访问能力增强（负载到不同的节点）- 范围条件查询性能提升（并行计算）缺点：- 数据扩容比较困难，设计到数据迁移问题- 数据库连接消耗比较多分片策略的选择：1） 确定分片表2） 找出分片键3） 考虑容量、增速、业务用户如果在查询语句中没有携带分片建，那么mycat会将sql发布到所有的节点上## 7. Mycat扩缩容### 7.1 在线不停机扩缩容（双写）![image-20201107205855474](./mycat/image-20201107205855474.png)### 7.2 离线扩缩容#### 7.2.1Mysql Dump```shellmysqldump -uroot -p123456 -h127.0.0.1 -p3306 -c -t --skip-extended-insert 数据库名称 &gt; mysql.11.11.sql 7.2.2 Mycat自带工具 mycat所在环境安装mysql客户端程序 mycat的lib目录下添加mysql的jdbc驱动包（mysql-connector-java-5.7.1.jar） 对扩容缩容的表所有节点数据进行备份 复制schema.xml、rule.xml并重命名为newSchema.xml、newRule.xml 修改newSchema.xml和newRule.xml配置文件为扩容缩容后的参数 在conf/migrateTable.properties配置文件中配置分片库和分片表如：imall=table_test1 dataMigrate.sh配置mysqldump路径 停止mycat服务 执行bin/dataMigrate.sh脚本（不能用openjdk） 替换schema.xml、rule.xml 注意事项： 保证分片表迁移数据前后路由规则一致（取模–&gt;取模） 保证分片表歉意数据前后分片字段一致 全局表将被忽略 不要将非分片表配置到migrateTables.properties文件中 暂时只支持分片表使用Mysql作为数据源的扩容缩容 8. Mycat读写分离 8.1 主从复制 数据备份回复 负载均衡（读写分离） 高可用HA 8.2 主从复制形式; binlog(Binary log 二进制日志) 12--查看binglog: SHOW binlog events in &#x27;mysql-bin.000001&#x27;--show variables like &#x27;max_blog_max&#x27; binlog配置 STATEMENT: 记录每一天修改数据的sql语句（减少日志量，节约IO） ROW: 记录哪条数据被修改了，修改成什么样子了（5.7以后默认） MIXED: 结合两种方式，一般语句用STATEMENT,函数之类的使用ROW binlog格式（mysql-bin.00001等） 查看binlog 1show binlog events in &#x27;mysql-bin.00001&#x27;; 主从复制原理 SQL Thread是单线程的， 这也是所有的主从复制延迟的原因，那么relay log接受master节点的sql语句主要是用于缓冲 mycat读写分离配置 8.5 Mycat注解（hint） 注解用法： 12345/*!mycat:sql=注解sql语句*/真正执行的SQL比如说在mycat上创建表无法创建成功，可以使用注解/*!mycat:sql=select * from table_1 where id = 1*/create table test2(id int);主要注解sql可以确认mycat可以路由到子结点上，就可以执行后面的真正执行的sql语句 注解用途： 跨库关联查询 DDL或存储过程 自定义分片 读写分离 分布式事务 基于XA协议的两阶段提交 XA角色 XA实现 9. Mycat核心流程 9.1 架构图 9.2 启动流程 MycatServer启动，解析配置文件，包括服务器、分片规则等 创建工作线程，建立前端连接和后端连接 9.3 执行SQL流程 前端连接接收mysql命令 解析MySQL，mycat用的是Druid的DruidParser 获取路由 改写MySQL，例如两个条件在两个节点上，则变成两条单独的sql 与后端数据库建立连接 发送sql语句到MySQL执行 获取返回结果 处理返回结果，例如排序、计算等等 返回给客户端 Mycat高可用","categories":[{"name":"中间件","slug":"中间件","permalink":"https://xiaoyuge5201.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"mycat","slug":"mycat","permalink":"https://xiaoyuge5201.github.io/tags/mycat/"}]},{"title":"mysql知识总结","slug":"mysql","date":"2021-07-23T08:00:57.000Z","updated":"2021-07-23T08:38:22.414Z","comments":false,"path":"2021/07/23/mysql/","link":"","permalink":"https://xiaoyuge5201.github.io/2021/07/23/mysql/","excerpt":"","text":"mysql 初识 1. 版本历史 1996年 mysql.10发布 1996年10月3.11.1发布 2000年ISAM升级成MyISAM引擎，mysql开源 2003年 Mysql4.0发布集成InnoDB存储引擎 2005年 MySQL 5.0版本发布，提供了试图，存储过程等功能 2010年MySQL5.5发布，InnoDB成为默认的存储引擎 2016年发布8.0.0版本 2. 流行分支 Maria DB Percona Server 3. SQL 执行流程 通信类型 同步 异步 连接方式 长连接 短连接 超时时间 非交互式超时时间，如JDBC程序，单位s 1SHOW GLOBAL VARIABLES LIKE &#x27;wait_timeout&#x27; 交互式超时间，如数据库工具 1SHOW GLOBAL variables LIKE &#x27;interactive_timeout&#x27; 查看连接 1show GLOBAL STATUS LIKE &#x27;Thread%&#x27; 连接名称 描述 Threads_cached 缓存中的线程 Threads_connected 连接中线程 Threads_created 创建过的线程 Threads_running 正在执行的线程 查看所有的线程 如果是root权限，可以看到所有用户发起的线程，否则只能看到自己的线程 1show processlist id ：一个表示，kill一个语句的时候可以使用 user：显示当前用户，如果不是root，这个命令就只显示你权限范围内的sql语句 host：显示这个语句是从哪个ip的端口上发出的，可以用来追踪出问题语句的用户 db：显示这个进程目前连接的是哪个数据库 commmand：显示当年连接的执行命令，一般分为休眠slee、查询query、连接connect time：此状态持续的时间，单位是秒 state： 显示使用当年连接的sql语句状态，state只是语句执行中的某一个状态，如查询：需要经过copying to tmp table、sorting result、sending data等转台才可以完成 info：显示这个sql语句，因为长度有限，所以长的sql语句就显示不全 查看最大连接数 1show variables LIKE &#x27;max_connections&#x27;; //一般默认是151，最大可以是2的14次方 mysql变量级别 global全局 1234在mysql中修改全局变量global有两种方法：1. 修改my.ini配置文件（永久有效）2. 在不修改配置文件的基础上，使用关键字global设置全局变量 set global autocommit = 1;将autocommit变量的值设置为ON，需要注意的是此方法对global全局变量的设计进对于新开启的会话有效，对已开启的会话无效，同理，如果修改回哈session变量，可以使用session关键字，如set session autocommit = 1；这个仅对本session的变量配置有效，对其他的session无效；（在MySQL服务重启之后，数据库的配置重新按照my.ini文件 初始化，global和session 的配置都会失效） session当前会话 通信协议 Unix Socket TCP/IP Named Pipes命名管道 Share Memory共享内存 通信方式 单工 半双工 全双工 MySQL 缓存 12SHOW VARIABLES LIKE &#x27;query_cache%&#x27;#默认关闭，是因为mysql要保证两次执行的sql完全一致，连空格，大小写都一致，而且当数据表中的任何一条数据发生变化，整个缓存会失效； #2. 删除数据 1. 数据删除方式 DELETE Truncate Drop 2. 执行速度 drop &gt; truncate &gt; delete 2.1 DELETE 1DELETE FROM table_name WHERE XXX DELETE 数据数据库DML操作语言，只删除数据不删除表的结构，会走事务，执行时会触发trigger 在InnoDB中，delete其实并不会真的把数据删除，mysqL实际上只是给删除的数据打个标记为删除，因此delete删除表中的数据，表文件在磁盘所占的控件不会变小，存储控件不会被释放，只是把删除的数据设置为不可见。虽然未释放磁盘控件，但是下次插入数据的时候，仍然可以重用这部分空间（重用-&gt;覆盖） delete执行时，会先把所删除数据缓存到rollback segement中，事务commit之后生效 delete from table_name 删除表的全部数据对于MyISAM会释放磁盘控件，Innodb不会释放磁盘空间 对于DELETE from table_name where xxx带条件的删除，不管是Innodb还是MyISAM都不会释放磁盘控件 delete 操作以后使用optimize table table_name会里级释放磁盘空间（不管是Innodb还是MyISAM） 123456--查看表占用磁盘空间大小select concat(round(sum(DATA_LENGTH/1024/1024),2),&#x27;M&#x27;) as table_sizefrom information_schema.tables where table_schema=&#x27;demo_db&#x27; AND table_name=&#x27;demo_table&#x27;;-- 执行空间优化语句，以及执行后的表size变化optimize table demo_table delete 操作时一行一行执行删除的，并且同时将该行的删除操作日志记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，生成大量日志也会占用磁盘空间 2.2 Truncate 123--删除表数据， 不带where条件--与不带where的delete ：只删除数据，而不删除表的结构 Truncate table table_name Truncate数据数据库DDL定义语言，不走事务，原数据不放到rollback segement中，操作不触发trigger，执行后里级生效，无法找回； truncate table table_name里级释放磁盘空间不管是Innodb 和MyISAM；truncate table其实有点类似余drop table然后create，只不过这个crate table的过程做了优化，比如表结构文件之前已经有了等，所以速度上应该是接近drop table的速度 truncate 能快速清空一个表，并且重置auto_increment的值 ​ 但是对于不同的类型存储引擎需要注意的地方是： 对于MyISAM：truncate会重置auto_increment（自增序列）的值为1，而delete后表仍然保持auto_increment。 对于Innodb：truncate会重置auto_increment（自增序列）的值为1， 而delete后表仍然保持auto_increment。但是在做delete整个表之后重启mysql的话，而重启后的auto_increment会被置为1 也就是说，Innodb的表本身是无法持久保存auto_increment。delete表之后auto_increment仍然保存在内存，但是重启后就丢失了，只能从1开始，实质上重启后的auto_increment会从SELETE 1+MAX(ai_col) FROM t开始 小心使用 truncate，尤其没有备份的时候，如果误删除线上的表，记得及时联系中国民航，订票电话：400-806-9553 2.3 Drop 12-- 删除表结构以及表数据Drop table table_name drop：属于数据库DDL定义语言，同Truncate； 执行后立即生效，无法找回！ 执行后立即生效，无法找回！ 执行后立即生效，无法找回！ **drop table table_name 立刻释放磁盘空间 ，不管是 InnoDB 和 MyISAM; **drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index); 依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。 小心使用 drop ，要删表跑路的兄弟，请在订票成功后在执行操作！订票电话：400-806-9553 3. 总结 可以这么理解，一本书，delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了","categories":[{"name":"mysql","slug":"mysql","permalink":"https://xiaoyuge5201.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://xiaoyuge5201.github.io/tags/mysql/"}]},{"title":"mysql事物","slug":"mysql事务","date":"2021-07-23T08:00:57.000Z","updated":"2021-07-23T08:46:56.676Z","comments":false,"path":"2021/07/23/mysql事务/","link":"","permalink":"https://xiaoyuge5201.github.io/2021/07/23/mysql%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务的定义 事务是数据管理系统DBMS执行过程中的一个逻辑单位，有一个有限的数据库操作序列构成 事务四大特性 原子性atomicity：依赖undolog做到全部失败 隔离性lsolation：实现方式LBCC 和 MVCC 持久性durability ：实现方式redolog和double write 一致性consistency：通过上面的三种方式实现 数据恢复： redo log 崩溃恢复 双写缓冲（double write） Mysql中insert、delete、update 自带事务 1234show veriables like ‘autocommit’;set session autocommit = on;update xxx where set xx =1 ;commit; 结束事务两种方式：rollback commit 事务并发的三大问题 数据并发的三大问题其实都是数据库读一致性问题，必须有数据库提供一定的事务隔离机制来解决。 脏读 不可重复读 幻读 事务隔离级别 http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt MVCC思想 Read View（一致性试图） 存储内容 Read View判断规则 RC与RR read View 的区别 所以RC解决不了脏读的问题 Mysql InnoDb所得基本类型 InnoDB支持行锁 MyiSAM支持行锁 表锁和行锁的区别 锁力度：表锁 &gt; 行锁 加锁效率：表锁 &gt; 行锁 冲突概率：表锁 &gt; 行锁 并发性能：表锁 &lt; 行锁 表锁 一个事务能够给一张表加上锁的前提是：没有其他任何一个事务锁定了这张表的任意一行数据。如果没有意向锁的话，那么加表锁需要扫描表中的每行数据，大大的浪费时间； 如果在添加行锁的时候，会在表上添加意向锁，那么在添加表锁的时候就不需要去扫描所有表数据了，只需要看下表上是否由意向锁就可； 行锁 共享锁shared locks 排它锁Exclusive locks Innodb行锁锁定的是什么 锁定的是index索引，如果表中没有索引，那么Innodb会把隐藏列DB_ROW_ID当作聚集索引 加锁一定要加上条件，不然会锁表 记录锁Rcord Lock 锁定记录 间隙锁Gap Lock 锁定范围 专门用于阻塞插入，间隙锁如果没有命中的话，会锁定最后一个值到正无穷，那么在最后一个值和正无穷之间的插入都不能成功。 临健锁Next-key Lock ：锁定范围加记录 为了解决幻读的问题 事务隔离级别的实现 事务隔离级别的选择","categories":[{"name":"mysql","slug":"mysql","permalink":"https://xiaoyuge5201.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://xiaoyuge5201.github.io/tags/mysql/"}]},{"title":"锁优化","slug":"lock01","date":"2021-07-23T06:04:02.000Z","updated":"2021-07-23T08:39:18.816Z","comments":false,"path":"2021/07/23/lock01/","link":"","permalink":"https://xiaoyuge5201.github.io/2021/07/23/lock01/","excerpt":"","text":"1. 优化思路以及方法 减少锁持有时间 减小锁粒度 锁分离 锁粗化 锁消除 1.1 减少锁持有时间 12345public synchronized void syncMethod()&#123; othercode1(); mutextMethod(); othercode2();&#125; 像上述代码，在进入方法前就要得到锁，其他线程就要在外面等待。 分析：锁里面的资源在同一时间只允许一个线程执行，我们不仅要减少其他线程等待的时间，也要尽力减少线程在锁里面的执行时间，所以，尽量只有在有线程安全要求的程序代码上加锁。 1234567public void syncMethod()&#123; othercode1(); synchronized(this)&#123; metextMethod(); &#125; othercode2();&#125; 1.2 减小锁粒度 将大对象（这个对象可能会被很多线程访问）拆成小对象，大大增加并行度。 降低锁竞争，那么偏向锁、轻量级锁成功率才会提高。 最最典型的减小锁粒度的案例就是ConcurrentHashMap。在HashMap的基础上进行优化，使用了cas与synchronized来确保安全性，在保证安全性的基础上为了充分利用线程资源，更是巧妙的设计了多线程同扩容的模式。 1.3 锁分离 最常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁。这样读读不互斥，读写互斥，写写互斥。既保证了线程安全，又提高了性能。 分析：读写分离这种思想可以延伸到我们其他的设计中，只要操作上互不影响，那锁就可以进行分离，比如：LinkedBlockingQueue 从头部获取数据，从尾部放入数据，使用两把锁。 1.4 锁粗化 通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁，只有这样，等待在这个锁上的其他线程才能尽早的获取资源执行任务；但是凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。 123456789public void demoMethod()&#123; synchronized&#123; //dow sth. &#125; //....做其他不需要同步的工作，但能很快执行完毕 synchronized&#123; //do sth. &#125;&#125; 这种情况，根据锁粗化的思想，应该合并： 1234567public void demoMethod()&#123; //整合成一次锁请求,前提时中间哪些不需要同步的工作很快就执行完成 synchronized(lock)&#123; //do sth. //....做其他不需要同步的工作，但能很快执行完毕 &#125;&#125; 再举一个极端的例子： 12345for(int i =0; i &lt; circle; i++)&#123; synchronized(lock)&#123; //..... &#125;&#125; 在一个循环内不同得获得锁。虽然JDK内部会对这个代码做些优化，但是还不如直接写成： 1234synchronized(lock)&#123; for(int i =0; i &lt; circle; i++)&#123; &#125;&#125; 当然如果有需求说，这样的循环太久，需要给其他线程不要等待太久，那只能写成上面那种。如果没有这样类似的需求，还是直接写成后者那种比较好。 分析: 锁粗化是JVM默认启动的一种机制，锁粗化针对的是对连续的区域进行分段加锁这种场景，JVM会自发进行优化。但作为开发者而言在满足业务的情况下，应该减少锁的使用。 1.5 锁消除 锁消除是在编译器级别的事情。在即时编译器(JIT)时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。也许你会觉得奇怪，既然有些对象不可能被多线程访问，那为什么要加锁呢？写代码时直接不加锁不就好了。 但是有时，这些锁并不是程序员所写的，有的是JDK实现中就有锁的，比如Vector和StringBuffer这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性能。 1234567891011121314public static void main(String args[]) throws InterrruptedException&#123; long start = System.currentTimeTimeMillis(); for(int i = 0;i &lt; 20000; i++)&#123; createStringBuffer(&quot;JVM&quot;,&quot;asdfasdfasdf&quot;); &#125; long bufferCost = System.currentTimeTimeMillis() - start; System.out.println(&quot;createStringBuffer:&quot;+bufferCost+&quot;ms&quot;);&#125;public static String createStringBuffer(String s1, String s2)&#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString();&#125; 上述代码中的StringBuffer.append是一个同步操作，但是StringBuffer却是一个局部变量，并且方法也并没有把StringBuffer返回，所以不可能会有多线程去访问它。那么此时StringBuffer中的同步操作就是没有意义的。 开启锁消除是在JVM参数上设置的，当然需要在server模式下： 1-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks 并且要开启逃逸分析。 逃逸分析的作用呢，就是看看变量是否有可能逃出作用域的范围。 比如上述的StringBuffer，上述代码中craeteStringBuffer的返回是一个String，所以这个局部变量StringBuffer在其他地方都不会被使用。如果将craeteStringBuffer改成 123456public static StringBuffer createStringBuffer(String s1, String s2)&#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb;&#125; 那么这个 StringBuffer被返回后，是有可能被任何其他地方所使用的（譬如被主函数将返回结果put进map啊等等）。那么JVM的逃逸分析可以分析出，这个局部变量 StringBuffer逃出了它的作用域。 所以基于逃逸分析，JVM可以判断，如果这个局部变量StringBuffer并没有逃出它的作用域，那么可以确定这个StringBuffer并不会被多线程所访问，那么就可以把这些多余的锁给去掉来提高性能。 当JVM参数为： 1-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks 输出： 1createStringBuffer: 302ms JVM参数为： 1-server -XX:+DoEscapeAnalysis -XX:-EliminateLocks 输出： 1createStringBuffer: 660ms 显然，锁消除的效果还是很明显的。","categories":[],"tags":[{"name":"lock","slug":"lock","permalink":"https://xiaoyuge5201.github.io/tags/lock/"}]},{"title":"ElasticSearch安装","slug":"ElasticSearch","date":"2021-07-23T05:41:24.000Z","updated":"2021-07-23T08:39:18.814Z","comments":false,"path":"2021/07/23/ElasticSearch/","link":"","permalink":"https://xiaoyuge5201.github.io/2021/07/23/ElasticSearch/","excerpt":"","text":"1. JDK14安装 下载jdk14： https://jdk.java.net/14/ 将文件存放在linux系统某文件夹内 解压 1tar -zxvf openjdk-14.0.2_linux-x64_bin.tar.gz 配置环境变量 123456vim /etc/profile##在文件最末尾添加，其中JAVA_HOME是jdk解压后的文件路径JAVA_HOME=/usr/lib/tools/jdk-14.0.2PATH=$JAVA_HOME/bin:$PATHCLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jarexport PATH JAVA_HOME CLASSPATH 保存后，更新配置文件 1source /etc/profile 查看JDK是否配置完成 1java -version 出现下图表示安装成功！ 2. ElasticSearch安装 解压tar.gz包 1tar -zxvf elasticsearch-7.8.0-linux-x86_64.tar.gz 添加elasticsearch用户 1useradd elastic 赋予elastic search操作文件夹的权限 1chown -R elastic:elastic /usr/lib/tools/elasticsearch-7.8.0/* 查看本机的hostname 12hostname#localhost.localdomain 修改elastic search配置 12 cd ./elasticsearch-7.8.0/configvim elasticsearch.yml elasticsearch.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# ======================== Elasticsearch Configuration =========================## NOTE: Elasticsearch comes with reasonable defaults for most settings.# Before you set out to tweak and tune the configuration, make sure you# understand what are you trying to accomplish and the consequences.## The primary way of configuring a node is via this file. This template lists# the most important settings you may want to configure for a production cluster.## Please consult the documentation for further information on configuration options:# https://www.elastic.co/guide/en/elasticsearch/reference/index.html## ---------------------------------- Cluster -----------------------------------## Use a descriptive name for your cluster:#集群名称，默认可以不修改，此处 xiaoyugecluster.name: xiaoyuge# ------------------------------------ Node ------------------------------------## Use a descriptive name for the node:#节点名称，必须修改 ，默认修改为当前机器名称，若是多实例则需要区分node.name: xiaoyuge-local1## Add custom attributes to the node:##node.attr.rack: r1## ----------------------------------- Paths ------------------------------------## Path to directory where to store the data (separate multiple locations by comma):##数据目录与日志目录，默认在当前运行程序下，生产环境需要指定#path.data: /path/to/data## Path to log files:##path.logs: /path/to/logs## ----------------------------------- Memory -----------------------------------## Lock the memory on startup:#内存交换锁定，此处需要操作系统设置才生效#bootstrap.memory_lock: true## Make sure that the heap size is set to about half the memory available# on the system and that the owner of the process is allowed to use this# limit.## Elasticsearch performs poorly when the system is swapping the memory.## ---------------------------------- Network -----------------------------------## Set the bind address to a specific IP (IPv4 or IPv6):#IP 地址，默认是 local，仅限本机访问，外网不可访问，设置 0.0.0.0 通用做法network.host: 192.168.135.111## Set a custom port for HTTP:#访问端口，默认 9200，9300，建议明确指定http.port: 9200transport.port: 9300## For more information, consult the network module documentation.## --------------------------------- Discovery ----------------------------------## Pass an initial list of hosts to perform discovery when this node is started:# The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]## 集群发现配置discovery.seed_hosts: [&quot;192.168.135.111:9300&quot;]## Bootstrap the cluster using an initial set of master-eligible nodes:#cluster.initial_master_nodes: [&quot;192.168.135.111:9300&quot;]## For more information, consult the discovery and cluster formation module documentation.## ---------------------------------- Gateway -----------------------------------## Block initial recovery after a full cluster restart until N nodes are started:##gateway.recover_after_nodes: 3## For more information, consult the gateway module documentation.## ---------------------------------- Various -----------------------------------## Require explicit names when deleting indices:##防止批量删除索引action.destructive_requires_name: true#设置密码xpack.security.enabled: truexpack.license.self_generated.type: trialxpack.security.transport.ssl.enabled: truehttp.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;http.cors.allow-headers: Authorization 切换为elastic search用户，然后启动elastic search 12su elastic #切换用户./bin/elasticsearch -d #后台启动 设置密码 12345678910111213141516171819202122232425./bin/elasticsearch-setup-passwords interactive#执行设置用户名和密码的命令,这里需要为4个用户分别设置密码，elastic, kibana, logstash_system,beats_systemInitiating the setup of passwords for reserved users elastic,kibana,logstash_system,beats_system.You will be prompted to enter passwords as the process progresses.Please confirm that you would like to continue [y/N]yEnter password for [elastic]:passwords must be at least [6] characters longTry again.Enter password for [elastic]:Reenter password for [elastic]:Passwords do not match.Try again.Enter password for [elastic]:Reenter password for [elastic]:Enter password for [kibana]:Reenter password for [kibana]:Enter password for [logstash_system]:Reenter password for [logstash_system]:Enter password for [beats_system]:Reenter password for [beats_system]:Changed password for user [kibana]Changed password for user [logstash_system]Changed password for user [beats_system]Changed password for user [elastic] 常见异常： 1234 #java.lang.RuntimeException: can not run elasticsearch as root #切换为elastic search用户，不能用root项目启动 su elastic 12345#Exception in thread &quot;main&quot; java.nio.file.AccessDeniedException: /usr/lib/tools/elasticsearch-7.8.0/config/elasticsearch.keystore#elastic search用户没有操作该文件夹的权限 su rootchown -R elastic:elastic /usr/lib/tools/elasticsearch-7.8.0/* 123456789101112131415161718ERROR: [2] bootstrap checks failed[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535][2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] #分配内存不够#1. 修改 /etc/security/limits.confsudo vi /etc/security/limits.conf#在文件末尾加上* soft nofile 65536* hard nofile 65536* soft nproc 4096* hard nproc 4096#2. 修改 /etc/sysctl.confsudo vi /etc/sysctl.conf#在文件末尾增加vm.max_map_count=262144#3. 配置重新生效sysctl -p 效果如下： 3. Kibana安装 解压文件 1tar -zxvf kibana-7.8.0-linux-x86_64.tar.gz 修改配置文件 1vim ./config/kibana.yml kibana.yml: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Kibana is served by a back end server. This setting specifies the port to use.##访问端口，默认无需修改server.port: 5601# Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.# The default is &#x27;localhost&#x27;, which usually means remote machines will not be able to connect.# To allow connections from remote users, set this parameter to a non-loopback address.#访问地址 IP，默认本地 ;如果需要外网访问，则配置0.0.0.0server.host: &quot;0.0.0.0&quot;# Enables you to specify a path to mount Kibana at if you are running behind a proxy.# Use the `server.rewriteBasePath` setting to tell Kibana if it should remove the basePath# from requests it receives, and to prevent a deprecation warning at startup.# This setting cannot end in a slash.#server.basePath: &quot;&quot;# Specifies whether Kibana should rewrite requests that are prefixed with# `server.basePath` or require that they are rewritten by your reverse proxy.# This setting was effectively always `false` before Kibana 6.3 and will# default to `true` starting in Kibana 7.0.#server.rewriteBasePath: false# The maximum payload size in bytes for incoming server requests.#server.maxPayloadBytes: 1048576# The Kibana server&#x27;s name. This is used for display purposes.#server.name: &quot;your-hostname&quot;# The URLs of the Elasticsearch instances to use for all your queries.# ES 服务指向，集群下配置多个elasticsearch.hosts: [&quot;http://192.168.135.111:9200&quot;]# When this setting&#x27;s value is true Kibana uses the hostname specified in the server.host# setting. When the value of this setting is false, Kibana uses the hostname of the host# that connects to this Kibana instance.#elasticsearch.preserveHost: true# Kibana uses an index in Elasticsearch to store saved searches, visualizations and# dashboards. Kibana creates a new index if the index doesn&#x27;t already exist.# Kibana 元数据存储索引名字，默认.kibana 无需修改#kibana.index: &quot;.kibana&quot;# The default application to load.#kibana.defaultAppId: &quot;home&quot;# If your Elasticsearch is protected with basic authentication, these settings provide# the username and password that the Kibana server uses to perform maintenance on the Kibana 启动 1234 # 当前窗口内启动 ./bin/kibana# #后台进程启动nohup ./bin/kibana &amp; 效果如下 遇见问题： root启动报错 12#切换到elastic账户su xiaoyuge elastic用户权限不足 Babel could not write cache to file: /usr/share/kibana/optimize/.babel_register_cache.json 1234567#切换到root用户su root #赋予elastic账户 xiaoyuge操作权限chown -R xiaoyuge /usr/local/kibana-7.7.1-linux-x86_64#切换为elastic账户su xiaoyuge#再次启动即可","categories":[],"tags":[{"name":"elasticSearch,kibana","slug":"elasticSearch-kibana","permalink":"https://xiaoyuge5201.github.io/tags/elasticSearch-kibana/"}]},{"title":"nginx安装.md","slug":"nginx","date":"2021-07-23T03:40:44.000Z","updated":"2021-07-23T08:44:16.882Z","comments":false,"path":"2021/07/23/nginx/","link":"","permalink":"https://xiaoyuge5201.github.io/2021/07/23/nginx/","excerpt":"","text":"Nginx简介 2000年地洞，c语言编写 2004年开源 2011年成立商业公司 2013 发布商业版本Nginx plus 2019.5月F5 networks收购nginx 2019.12被Rambler集团起诉 ##Nginx与其他web服务器对比 Nginx与A pace HTTP server project区别 Nginx 和tomcat区别 Nginx是HTTP Server，主要是用于访问一些静态资源，可以用做代理服务器 tomcat是Application Server应用服务器 HTTP Server 和Application Server区别与联系 Nginx安装 安装nginx前首先要确认系统中是否安装了gcc 、pcre-devel、zlib-devel、openssl-devel 1234#1、rpm包安装的，可以用 rpm -qa 看到，如果要查找某软件包是否安装，用 rpm -qa | grep &quot;软件或者包的名字&quot;#2、以deb包安装的，可以用 dpkg -l 看到。如果是查找指定软件包，用 dpkg -l | grep &quot;软件或者包的名字&quot;#3、yum方法安装的，可以用 yum list installed 查找，如果是查找指定包，用 yum list installed | grep &quot;软件名或者包名&quot;yum list installed | grep &quot;gcc&quot; 安装依赖包 1yum -y install gcc pcre-devel zlib-devel openssl openssl-devel 下载并解压安装包 1234567//创建nginx存放文件夹cd /usr/localmkdir nginxcd nginx#下载tar包wget http://nginx.org/download/nginx-1.13.7.tar.gztar -xvf nginx-1.13.7.tar.gz 配置 12345cd nginx-1.13.7./configure --prefix=/usr/local/nginxmakemake install 测试是否安装成功 1./sbin/nginx -t 配置nginx.conf 1234567891011121314151617181920vim /usr/local/nginx/cong/nginx.conf#修改如下server &#123; listen 80; server_name localhost; # 注意设定 root路径是有dist的 location / &#123; root /usr/local/webapp/dist; index /index.html; &#125; #跨域 ip和port自行替换 location /adminApi &#123; proxy_pass http://ip:port; &#125;&#125; 启动 123#启动nginxcd /usr/local/nginx/sbin./nginx 常用命令： 123456789101112131415161718192021222324252627282930313233343536373839404142#修改配置后重新启动./nginx -s reload#如果出现：nginx: [error] open() ＂/usr/local/nginx/logs/nginx.pid＂ failed/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf#再次启动即可#查看nginx进程是否启动ps -ef|grep nginx#平滑启动nginxkill -HUP#主进程号或进程号文件路径 或者使用/usr/nginx/sbin/nginx -s reload#注意，修改了配置文件后最好先检查一下修改过的配置文件是否正 确，以免重启后Nginx出现错误影响服务器稳定运行。#判断Nginx配置是否正确命令如下：nginx -t -c /usr/nginx/conf/nginx.conf#或者使用/usr/nginx/sbin/nginx -t#重启nginx reload/usr/local/nginx/sbin/nginx -s reload service nginx restart#启动./nginx#关闭./nginx -s stop#配置nginx开机自启动vim /etc/rc.d/rc.local#再文件中添加nginx启动地址 touch /var/lock/subsys/local/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf#设置开机自启动nginx/usr/local/nginx/sb/nginx 启动后访问localhost 效果如下： Nginx配置 12345678910...... 全局块events &#123; //events 块&#125;http&#123; .... http全局块 server+&#123; location +[] &#125;&#125; 配置内容规则 用#表示注释 每行配置的结尾需要加上分号 如果配置项值中包括语法符号，比如空格符，那么需要使用单引号或者双引号行括住配置项值，否则ngin x会报语法错误 单位简写： K或者k千字节（kilo byte, KB） M或者m兆字节（megabyte MB） ms(毫秒)，s(秒)， m(分)， h(小时) ， d (天)， w（周）， M（月，包含30天），y（年）","categories":[{"name":"linux","slug":"linux","permalink":"https://xiaoyuge5201.github.io/categories/linux/"},{"name":"nginx","slug":"linux/nginx","permalink":"https://xiaoyuge5201.github.io/categories/linux/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://xiaoyuge5201.github.io/tags/nginx/"}]},{"title":"vue学习","slug":"vue","date":"2021-07-23T03:40:44.000Z","updated":"2021-07-23T08:46:35.191Z","comments":false,"path":"2021/07/23/vue/","link":"","permalink":"https://xiaoyuge5201.github.io/2021/07/23/vue/","excerpt":"","text":"Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。 1. export 用于规定模块的对外接口，export输出变量和方法、类 变量 1234567// profile.jsexport var firstName = &#x27;Michael&#x27;;export var lastName = &#x27;Jackson&#x27;;export var year = 1958;//简写--优先使用export &#123;firstName, lastName, year&#125; 方法 123//如果想为输入的变量重新命名， 可以使用AS 关键字重新命名import &#123; buildMenus as buildMenus&#125; from &#x27;@/api/menu&#x27;;//import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同 2. export default 为模块指定默认输出， 使用import命令的时候，用户需要知道所要加载的变量名和函数名，否则无法加载；了解模块有哪些方法和属性比较麻烦，使用export default命令，为模块指定默认输出 1234// export-default.jsexport default function () &#123; console.log(&#x27;foo&#x27;);&#125; 上面代码是一个模块文件export-default.js。默认输出1个函数； 与export命令的区别：其他模块加载该模块是，import命令可以为该匿名函数指定任意名字 123// import-default.jsimport customName from &#x27;./export-default&#x27;;customName(); // &#x27;foo&#x27; 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 123456789101112// modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as foo &#125; from &#x27;modules&#x27;;// 等同于// import foo from &#x27;modules&#x27;; 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。 总结： export命令对外接口是有名称的且import命令从模块导入的变量名与被导入模块对外接口的名称相同，而export default命令对外输出的变量名可以是任意的，这时import命令后面，不使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。 12345678910111213141516171819202122232425262728293031323334//menu.js//get请求获取所有的菜单信息export function buildMenus() &#123; return request(&#123; url: &#x27;api/menus/build&#x27;, method: &#x27;get&#x27; &#125;)&#125;//post 请求保存数据export function add(data) &#123; return request(&#123; url: &#x27;api/menus&#x27;, method: &#x27;post&#x27;, data &#125;)&#125;//delete 请求删除数据export function del(id) &#123; return request(&#123; url: &#x27;api/menus/&#x27; + id, method: &#x27;delete&#x27; &#125;)&#125;//put请求修改数据export function edit(data) &#123; return request(&#123; url: &#x27;api/menus&#x27;, method: &#x27;put&#x27;, data &#125;)&#125;//app.vueimport &#123; buildMenus &#125; from &#x27;@/api/menu&#x27;; 3. Const、var、let ES5 中作用域有：全局作用域、函数作用域。没有块作用域的概念。 ES6 中新增了块级作用域。块作用域由 { } 包括，if语句和 for语句里面的{ }也属于块作用域 12345678910111213141516171819202122232425&#123; var a = 1; console.log(a); // 1&#125;console.log(a); // 1// 通过var定义的变量可以跨块作用域访问到。(function A() &#123; var b = 2; console.log(b); // 2&#125;)();// console.log(b); // 报错，// 可见，通过var定义的变量不能跨函数作用域访问到if(true) &#123; var c = 3;&#125;console.log(c); // 3for(var i = 0; i &lt; 4; i ++) &#123; var d = 5;&#125;;console.log(i); // 4 (循环结束i已经是4，所以此处i为4)console.log(d); // 5// if语句和for语句中用var定义的变量可以在外面访问到，// 可见，if语句和for语句属于块作用域，不属于函数作用域 三者的区别： var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。 1234567891011121314151617181920212223242526272829303132// 块作用域&#123; var a = 1; let b = 2; const c = 3; // c = 4; // 报错 var aa; let bb; // const cc; // 报错 console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(aa); // undefined console.log(bb); // undefined&#125;console.log(a); // 1// console.log(b); // 报错// console.log(c); // 报错// 函数作用域(function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 console.log(f); // 7 &#125;)();// console.log(d); // 报错// console.log(e); // 报错// console.log(f); // 报错 注意：const定义的对象属性是否可以改变 123456const person = &#123; name : &#x27;jiuke&#x27;, sex : &#x27;男&#x27;&#125;person.name = &#x27;test&#x27;console.log(person.name)//person对象的name属性确实被修改了 因为对象是引用类型的，person中保存的仅是对象的指针，这就意味着，const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。 然后我们试着修改一下指针，让person指向一个新对象，果然报错 123456789const person = &#123; name : &#x27;jiuke&#x27;, sex : &#x27;男&#x27;&#125;person = &#123; name : &#x27;test&#x27;, sex : &#x27;男&#x27;&#125;//报错 4. promise promise用途：异步编程的一种解决方案。 优点：比传统的解决方案——回调函数和事件——更合理和更强大。 三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。 123456789101112131415161718//基本用法：const promise = new Promise(function(resolve, reject) &#123; resolve(value);//表示异步操作成功 reject(error);//表示异步操作失败&#125;);//promise常用的几个方法//1. 异步状态为成功时调用第一个函数，为失败时调用第二个函数。then方法的第二个参数可选。promise.then(value =&gt; &#123;&#125;,error =&gt; &#123;&#125;);//2. 异步状态为失败时调用。promise.catch(error =&gt; &#123;&#125;);//3. promise异步状态为失败时或then方法中抛出错误都会执行catch方法。promise.then(value =&gt; &#123;&#125;,error =&gt; &#123;&#125;).catch(error =&gt; &#123;&#125;);//4. 不管状态如何都会执行的操作。promise.finally(() =&gt; &#123;&#125;); 5. 生命周期 6. 模版语法 v-once 执行一次性插值，当数据变化的时候，该内容不会更新；可能会影响该节点其他的数据绑定 1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-html 双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用v-html; 1234var rawHtml = &quot;&lt;span&gt;这是个使用v-htmls&lt;/span&gt;&quot;&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; Attribute Mustache ({}) 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind 指令： 12345&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;//isButtonDisabled 的值是 null、undefined 或 false，则 disabled attribute 甚至不会被包含在渲染出来的 &lt;button&gt; 元素中&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; 三元表达式 1234567891011121314&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;div v-bind:id=&quot;&#x27;list-&#x27; + id&quot;&gt;&lt;/div&gt;//这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 7. 指令Directives 指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 12//v-if 指令将根据表达式 seen 的值的真假来插入/移除 &lt;p&gt; 元素。&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt; 参数 一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML attribute 1234//href 是参数，告知 v-bind 指令将该元素的 href attribute 与表达式 url 的值绑定&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt; 动态参数 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数 12345&lt;a v-bind:[attributeName] = &quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 这里的attributeName会被作为一个javascript表达式进行动态赋值，求得的值会作为最终的参数来使用如果VUE实例有一个data. property. attributeName， 其值为href， 那么绑定将等价于v-bind:href---&gt; 绑定处理函数： 1&lt;a v-on:[eventName]=&quot;dosomething&quot;&gt;&lt;/a&gt; 对动态参数的值的约束 动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。 对动态参数表达式的约束 动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如： 修饰符 修饰符（modifier）是以半角句号. 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定；例如.prevent修饰符告诉v-on指令对触发的事件调用event.preventDefault(); 123&lt;form v-on:submit.prevent = &quot;onSubmit&quot;&gt; &lt;/form&gt; 缩写 123456789101112131415161718&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; : 与 @ 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。 8. 计算属性 123&lt;div id=&quot;example&quot;&gt; &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/div&gt; 这里是想要显示变量 message 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。 所以，对于任何复杂逻辑，你都应当使用计算属性 例如： 1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617var vm = new Vue(&#123; el: &#x27;#example&#x27;, data: &#123; message: &#x27;Hello&#x27; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125;&#125;)//页面显示：//Original message: &quot;Hello&quot;//Computed reversed message: &quot;olleH&quot; 声明了一个计算属性reversedMessage；我们提供的函数将用作property vm.reversedMessage的getter函数 123console.log(vm.reversedMessage) // olleHvm.message = &#x27;Goodbye&#x27;console.log(vm.reversedMessage) // =&gt; &#x27;eybdooG&#x27; 你可以打开浏览器的控制台，自行修改例子中的 vm。vm.reversedMessage 的值始终取决于 vm.message 的值。 你可以像绑定普通 property 一样在模板中绑定计算属性。Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的。 计算属性 VS 方法 使用表达式中调用方法同样可以达到上面的结果 1&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt; 123456// 在组件中methods: &#123; reversedMessage: function () &#123; return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125; 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖： 12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 计算属性 VS 侦听属性 侦听属性：vue提供了一种更通用的方式来观察和响应vue实例上的数据变动；当有一些数据需要随着其他数据变动而变动时；很容易滥用watch;通常更好的做法是使用计算属性而不是命令式的watch回调； 1&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; 123456789101112131415161718192021222324var vm = new Vue(&#123; el: &#x27;#demo&#x27;, data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27;, fullName: &#x27;Foo Bar&#x27; &#125;, //侦听属性watch watch: &#123; firstName: function (val) &#123; this.fullName = val + &#x27; &#x27; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &#x27; &#x27; + val &#125; &#125;, //计算属性 computed: &#123; fullName: function () &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125;&#125;) 计算属性的setter 计算属性默认只有getter，自己可以提供一个setter 1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&#x27; &#x27;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 现在再运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 9. 侦听器 当需要在数据变化时执行异步或开销较大的操作时，watch是最有用的；同时也可以自定义侦听器； 1234567&lt;div id=&quot;watch-example&quot;&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=&quot;question&quot;&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: &#x27;#watch-example&#x27;, data: &#123; question: &#x27;&#x27;, answer: &#x27;I cannot give you an answer until you ask a question!&#x27; &#125;, watch: &#123; // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = &#x27;Waiting for you to stop typing...&#x27; this.debouncedGetAnswer() &#125; &#125;, created: function () &#123; // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， // 请参考：https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) &#125;, methods: &#123; getAnswer: function () &#123; if (this.question.indexOf(&#x27;?&#x27;) === -1) &#123; this.answer = &#x27;Questions usually contain a question mark. ;-)&#x27; return &#125; this.answer = &#x27;Thinking...&#x27; var vm = this axios.get(&#x27;https://yesno.wtf/api&#x27;) .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) //异常捕获 .catch(function (error) &#123; vm.answer = &#x27;Error! Could not reach the API. &#x27; + error &#125;) &#125; &#125;&#125;)&lt;/script&gt; 使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的 10. class与style绑定 将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组 10.1 绑定html class 10.1.1对象语法 方式一：内联 123456789&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt;//datadata: &#123; isActive: true, hasError: false&#125; 方式二：绑定的数据对象不必内联定义在模板里 12345678&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;//vue datadata: &#123; classObject: &#123; active: true, &#x27;text-danger&#x27;: false &#125;&#125; 方式三：绑定一个返回对象的计算属性（常用） 123456789101112131415&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;//vue datadata: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27; &#125; &#125;&#125; 10.1.2 数组语法","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaoyuge5201.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"https://xiaoyuge5201.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://xiaoyuge5201.github.io/tags/vue/"}]},{"title":"Java 8学习","slug":"java8特性","date":"2020-04-23T06:04:02.000Z","updated":"2021-07-23T08:43:57.786Z","comments":false,"path":"2020/04/23/java8特性/","link":"","permalink":"https://xiaoyuge5201.github.io/2020/04/23/java8%E7%89%B9%E6%80%A7/","excerpt":"","text":"1. Optional 1.1. optional构造方式 Optional.of(T) 该方式的入参不能为null，否则会有NPE，在确定入参不为空时使用该方式。 Optional.ofNullable(T) 该方式的入参可以为null，当入参不确定为非null时使用。 Optional.empty() 这种方式是返回一个空Optional，等效Optional.ofNullable(null) 1.2. 如何正确的使用Optional 尽量避免使用的地方 避免使用Optional.isPresent()来检查实例是否存在，因为这种方式和null != obj没有区别，这样用就没什么意义了。 避免使用Optional.get()方式来获取实例对象，因为使用前需要使用Optional.isPresent()来检查实例是否存在，否则会出现NPE问题。 避免使用Optional作为类或者实例的属性，而应该在返回值中用来包装返回实例对象。 避免使用Optional作为方法的参数，原因同3。 正确使用方式 实例对象存在则返回，否则提供默认值或者通过方法来设置返回值，即使用orElse/orElseGet方式： 12345678910111213141516171819202122//存在则返回User king = new User(1, &quot;king&quot;);Optional&lt;User&gt; userOpt = Optional.of(king);User user = userOpt.orElse(null);System.out.println(user.getName());//不存在提供默认值User user2 = null;Optional&lt;User&gt; userOpt2 = Optional.ofNullable(user2);User user3 = userOpt2.orElse(unknown);System.out.println(user3.getName());//通过方法提供值User user4 = userOpt2.orElseGet(() -&gt; new User(0, &quot;DEFAULT&quot;)); System.out.println(user4.getName()) //不建议下面这种使用if(userOpt.isPresent()) &#123; System.out.println(userOpt.get().getName());&#125; else &#123; //。。。&#125; 使用ifPresent()来进行对象操作，存在则操作，否则不操作。 123//实例存在则操作，否则不操作userOpt.ifPresent(u -&gt; System.out.println(u.getName()));userOpt2.ifPresent(u -&gt; System.out.println(u.getName())); 使用map/flatMap来获取关联数据 1234567891011//使用map方法获取关联数据System.out.println(userOpt.map(u -&gt; u.getName()).orElse(&quot;Unknown&quot;));System.out.println(userOpt2.map(u -&gt; u.getName()).orElse(&quot;Default&quot;));//使用flatMap方法获取关联数据List&lt;String&gt; interests = new ArrayList&lt;String&gt;();interests.add(&quot;a&quot;);interests.add(&quot;b&quot;);interests.add(&quot;c&quot;);user.setInterests(interests);List&lt;String&gt; interests2 = Optional.of(user) .flatMap(u -&gt; Optional.ofNullable(u.getInterests())) .orElse(Collections.emptyList());System.out.println(interests2.isEmpty()); 1.3.Optional判断第三方接口 使用java8的optional可以减少很多的NPE，再也不用当心别人的接口返回值问题了，也不用满屏的if（a != null）这种判断，下面是使用过程中遇到的问题以及如何使用Optional解决。 1.3.1. 接口返回参数问题 在微服务中使用feign调用其他接口，总担心别人返回的参数是否符合标准 参数符合标准后，然后再进行数据判断，先判断是否code为200，然后判断数据存不存在，这样冗余的代码就很多 这是我们期望的返回格式 12345&#123; &quot;code&quot;: &quot;200&quot;, &quot;msg&quot;: &quot;调用成功!&quot;, &quot;data&quot;: []&#125; 12345678//模拟接口调用方法Map&lt;String,Object&gt; map = serviceImpl.queryList();//即使map为空也能正常返回，配合map直接映射数据值return Optional.ofNullable(map).map(r-&gt; r.get(&quot;data&quot;)).orElseGet(ArrayList:: new) //JSONObject 判断是否返回成功，如果成功返回200， 不成功返回400 JSONObject jsonObject = service.updateDate();Optional.ofNullable(jsonObject).map(r-&gt;r.getInteger(&quot;code&quot;)).orElse(400) 1.3.2. 避免判断风暴 对象层层嵌套，为了逻辑严谨必须要进行空判断 1234567891011121314151617181920//对于一个对象里面嵌套对象，那么需要层层去判断非空School school = null;if(school != null)&#123; Clazz clazz = school.getClazz(); if(clazz != null)&#123; Student student = clazz.getStudent(); if(student != null)&#123; String name = student.getName(); if(name == null || &quot;&quot;.equals(name))&#123; name = &quot;学生的姓名为空&quot;; &#125; &#125; &#125;&#125;//使用Optional后 String name = Optional.ofNullable(school) .map(School::getClazz) .map(Clazz::getStudent) .map(Student::getName) .orElse(&quot;学生的姓名为空&quot;); 2. Stream 123//找出某一个字段等于某个值的那一条数据JaponicaRiceCheck1 streamCheck = listItemRice.stream().filter(o -&gt; o.getSYS_PARENTID().equals(check.getSYS_ID())).findAny().orElse(null);","categories":[{"name":"java","slug":"java","permalink":"https://xiaoyuge5201.github.io/categories/java/"}],"tags":[{"name":"Optional","slug":"Optional","permalink":"https://xiaoyuge5201.github.io/tags/Optional/"}]}],"categories":[{"name":"中间件","slug":"中间件","permalink":"https://xiaoyuge5201.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"mysql","slug":"mysql","permalink":"https://xiaoyuge5201.github.io/categories/mysql/"},{"name":"linux","slug":"linux","permalink":"https://xiaoyuge5201.github.io/categories/linux/"},{"name":"nginx","slug":"linux/nginx","permalink":"https://xiaoyuge5201.github.io/categories/linux/nginx/"},{"name":"前端","slug":"前端","permalink":"https://xiaoyuge5201.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"https://xiaoyuge5201.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"java","slug":"java","permalink":"https://xiaoyuge5201.github.io/categories/java/"}],"tags":[{"name":"mycat","slug":"mycat","permalink":"https://xiaoyuge5201.github.io/tags/mycat/"},{"name":"mysql","slug":"mysql","permalink":"https://xiaoyuge5201.github.io/tags/mysql/"},{"name":"lock","slug":"lock","permalink":"https://xiaoyuge5201.github.io/tags/lock/"},{"name":"elasticSearch,kibana","slug":"elasticSearch-kibana","permalink":"https://xiaoyuge5201.github.io/tags/elasticSearch-kibana/"},{"name":"nginx","slug":"nginx","permalink":"https://xiaoyuge5201.github.io/tags/nginx/"},{"name":"vue","slug":"vue","permalink":"https://xiaoyuge5201.github.io/tags/vue/"},{"name":"Optional","slug":"Optional","permalink":"https://xiaoyuge5201.github.io/tags/Optional/"}]}